rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    //------------------------------------------------//
    //                 Helper Functions               //
    //------------------------------------------------//
    
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function getUserData(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data;
    }

    function isAdmin() {
      // Checks if the requesting user is an admin.
      return isSignedIn() && getUserData(request.auth.uid).role == 'admin';
    }

    function isTaskOwner(taskId) {
      return isUser(get(/databases/$(database)/documents/tasks/$(taskId)).data.ownerUid);
    }
    
    function isAssignedToTask(taskId) {
      return isSignedIn() && get(/databases/$(database)/documents/tasks/$(taskId)).data.assignedToUids.hasAny([request.auth.uid]);
    }

    //------------------------------------------------//
    //                 Collection Rules               //
    //------------------------------------------------//
    
    match /users/{userId} {
      // Admins can read/write any user document.
      // Users can read/write their own document.
      allow read, write: if isAdmin() || isUser(userId);
    }
    
    match /projects/{projectId} {
      function isOwner() {
        return isUser(get(/databases/$(database)/documents/projects/$(projectId)).data.ownerUid);
      }
      function isClient() {
        // This performs two reads, which is inefficient but syntactically correct and necessary without 'let'
        return get(/databases/$(database)/documents/projects/$(projectId)).data.clientUid != null 
                && isUser(get(/databases/$(database)/documents/projects/$(projectId)).data.clientUid);
      }

      // Read: Project Owner, Admin, or assigned Client.
      allow read: if isSignedIn() && (isOwner() || isAdmin() || isClient());
      // Create: Any signed-in user. App logic restricts roles.
      allow create: if isSignedIn();
      // Update/Delete: Project Owner or Admin.
      allow update, delete: if isSignedIn() && (isOwner() || isAdmin());
    }
    
    match /tasks/{taskId} {
      // Local functions to avoid repeated 'get' calls.
      function task() { return get(/databases/$(database)/documents/tasks/$(taskId)).data; }
      function isTaskAssigned() { return isSignedIn() && task().assignedToUids.hasAny([request.auth.uid]); }
      function isProjectOwnerForTask() { return isUser(task().projectOwnerUid); }

      // Read: Project Owner, Task Owner, Assigned User, or Admin.
      allow read: if isSignedIn() && (isProjectOwnerForTask() || isUser(task().ownerUid) || isTaskAssigned() || isAdmin());
      // Create: User must be the owner of the parent project or an admin.
      allow create: if isSignedIn() && (isUser(get(/databases/$(database)/documents/projects/$(request.resource.data.projectId)).data.ownerUid) || isAdmin());
      // Update: Task Owner or an Assigned User.
      allow update: if isSignedIn() && (isUser(task().ownerUid) || isTaskAssigned());
      // Delete: Only the Task Owner.
      allow delete: if isUser(task().ownerUid);
      
      // Subcollections
      match /timeline/{eventId} {
        allow read: if isSignedIn() && (isProjectOwnerForTask() || isUser(task().ownerUid) || isTaskAssigned() || isAdmin());
        allow create: if isSignedIn(); // Logged by trusted logic.
      }
      match /attachments/{attachmentId} {
        allow read, create: if isSignedIn() && (isProjectOwnerForTask() || isUser(task().ownerUid) || isTaskAssigned() || isAdmin());
        allow delete: if isUser(resource.data.ownerUid);
      }
    }
    
    match /issues/{issueId} {
      // Local functions
      function issue() { return get(/databases/$(database)/documents/issues/$(issueId)).data; }
      function isAssignedToIssue() { return isSignedIn() && issue().assignedToUids.hasAny([request.auth.uid]); }
      function isProjectOwnerForIssue() { return isUser(issue().projectOwnerUid); }
      
      // Read: Project Owner, Task Owner, Issue Owner, Assigned User, Admin.
      allow read: if isSignedIn() && (isProjectOwnerForIssue() || isTaskOwner(issue().taskId) || isUser(issue().ownerUid) || isAssignedToIssue() || isAdmin());
      // Create: Task Owner or someone assigned to the task.
      allow create: if isSignedIn() && (isTaskOwner(request.resource.data.taskId) || isAssignedToTask(request.resource.data.taskId));
      // Update: Issue Owner or someone assigned to the issue.
      allow update: if isSignedIn() && (isUser(issue().ownerUid) || isAssignedToIssue());
      // Delete: Only the Issue Owner.
      allow delete: if isUser(issue().ownerUid);
    }
    
    match /attendance/{recordId} {
      // Read: Only Admins.
      allow read: if isAdmin();
      // Create: User can only create their own record.
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
    }
  }
}
