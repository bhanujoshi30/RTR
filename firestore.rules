rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks a user's role. This performs a single document read.
    function isUserRole(uid, role) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(uid)).data.role == role;
    }
    
    // Checks if the user is an admin.
    function isAdmin() {
        return isUserRole(request.auth.uid, 'admin');
    }

    // --- Collections ---

    // Users Collection
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create, update: if isAdmin();
      allow delete: if isAdmin() && request.auth.uid != userId; // Admins can't delete themselves
    }

    // Projects Collection
    match /projects/{projectId} {
      // Any authenticated user can read project details.
      // App logic ensures users only query for projects they are involved in.
      allow read: if isSignedIn();
      
      // Only authenticated users who are not supervisors or members can create projects.
      allow create: if isSignedIn() &&
                    !isUserRole(request.auth.uid, 'supervisor') &&
                    !isUserRole(request.auth.uid, 'member');
                    
      // Only the project owner can update or delete a project.
      allow update, delete: if isSignedIn() && resource.data.ownerUid == request.auth.uid;
    }

    // Tasks Collection
    match /tasks/{taskId} {
      // This rule is designed to be efficient for list queries.
      // It does NOT use get() and relies on denormalized data on the task document.
      allow read: if isSignedIn() &&
                    (
                      // Main tasks are readable by any auth'd user. App filters relevance.
                      resource.data.parentId == null ||
                      
                      // Sub-tasks are readable by...
                      resource.data.projectOwnerUid == request.auth.uid || // Project Owner
                      (resource.data.clientUid != null && resource.data.clientUid == request.auth.uid) || // Assigned Client
                      resource.data.ownerUid == request.auth.uid || // Task Creator
                      request.auth.uid in resource.data.assignedToUids // Assigned User
                    );

      allow create: if isSignedIn(); // Logic is checked in the service layer before creation

      allow update: if isSignedIn() && 
                    ( 
                      // Project owner can update anything
                      resource.data.ownerUid == request.auth.uid ||
                      // Assigned users can update their own sub-tasks
                      (resource.data.parentId != null && request.auth.uid in resource.data.assignedToUids)
                    );
                    
      allow delete: if isSignedIn() && resource.data.ownerUid == request.auth.uid;

      // --- Sub-collections ---

      match /attachments/{attachmentId} {
        // Here, a get() is acceptable because the parent taskId is known for the query path
        let task = get(/databases/$(database)/documents/tasks/$(taskId)).data;
        
        allow read: if isSignedIn() &&
                      (
                        task.projectOwnerUid == request.auth.uid ||
                        (task.clientUid != null && task.clientUid == request.auth.uid) ||
                        task.ownerUid == request.auth.uid ||
                        request.auth.uid in task.assignedToUids
                      );

        allow create: if isSignedIn() && request.auth.uid == request.resource.data.ownerUid;
        allow delete: if isSignedIn() && resource.data.ownerUid == request.auth.uid;
      }
      
      match /timeline/{eventId} {
        let task = get(/databases/$(database)/documents/tasks/$(taskId)).data;
        
        allow read: if isSignedIn() &&
                        (
                          task.projectOwnerUid == request.auth.uid ||
                          (task.clientUid != null && task.clientUid == request.auth.uid) ||
                          task.ownerUid == request.auth.uid ||
                          request.auth.uid in task.assignedToUids
                        );

        allow create: if isSignedIn(); // Logged by trusted server-side logic/user action
      }
    }
    
    // Issues Collection
    match /issues/{issueId} {
      // This rule is designed to be efficient for list queries.
      // It does NOT use get() and relies on denormalized data on the issue document.
      allow read: if isSignedIn() &&
              (
                resource.data.projectOwnerUid == request.auth.uid ||
                (resource.data.clientUid != null && resource.data.clientUid == request.auth.uid) ||
                resource.data.ownerUid == request.auth.uid ||
                request.auth.uid in resource.data.assignedToUids
              );
              
      allow create: if isSignedIn(); // Logic checked in service layer

      allow update: if isSignedIn() && 
                    (
                      resource.data.ownerUid == request.auth.uid || // Issue creator
                      request.auth.uid in resource.data.assignedToUids // Assigned users
                    );
                    
      allow delete: if isSignedIn() && resource.data.ownerUid == request.auth.uid; // Only creator can delete
    }

    // Attendance Collection
    match /attendance/{recordId} {
      // Admins can read all records.
      allow read: if isAdmin();
      // Users can only create their own attendance records.
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      // No updates or deletes allowed.
      allow update, delete: if false;
    }
  }
}
