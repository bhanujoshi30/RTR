
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isAdmin() {
      // This is now safe because the /users/{userId} read rule does not depend on isAdmin()
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    match /users/{userId} {
      // Allow any authenticated user to read user profiles for display names, roles, etc.
      // This breaks the recursive dependency that was causing query failures.
      allow read: if request.auth != null;
      // Only admins can create, update, or delete user documents.
      allow write: if isAdmin();
      allow delete: if isAdmin() && request.auth.uid != userId;
    }

    match /projects/{projectId} {
      function isProjectOwner() {
        return request.auth.uid == resource.data.ownerUid;
      }
      function isProjectClient() {
        return request.auth.uid == resource.data.clientUid;
      }
      function isProjectMember() {
        // Check if the user is explicitly listed as a member.
        return request.auth.uid in resource.data.memberUids;
      }

      allow read: if isAdmin() || isProjectOwner() || isProjectClient() || isProjectMember();
      allow create: if request.auth != null && request.resource.data.ownerUid == request.auth.uid;
      allow update: if isAdmin() || isProjectOwner();
      allow delete: if isAdmin() || isProjectOwner();
    }

    match /tasks/{taskId} {
      let task = resource.data;
      
      function isProjectOwner() {
        return request.auth.uid == get(/databases/$(database)/documents/projects/$(task.projectId)).data.ownerUid;
      }
      function isProjectClient() {
        return request.auth.uid == get(/databases/$(database)/documents/projects/$(task.projectId)).data.clientUid;
      }
      function isTaskOwner() {
        return request.auth.uid == task.ownerUid;
      }
      function isAssignedToTask() {
        return request.auth.uid in task.assignedToUids;
      }
      function isMemberOfMainTask() {
        // For reading main tasks, check if the user is in the denormalized member list.
        return task.parentId == null && request.auth.uid in task.memberUids;
      }

      // Read access: Admin, project owner/client, or a user assigned to the task.
      allow read: if isAdmin() || isProjectOwner() || isProjectClient() || isTaskOwner() || isAssignedToTask() || isMemberOfMainTask();

      // Create access: Any authenticated user can create a task (permissions are checked in service code against project).
      allow create: if request.auth != null;
      
      // Update/Delete access: More restrictive, only the task owner or an admin.
      allow update, delete: if isAdmin() || isTaskOwner();

      // Subcollections
      match /attachments/{attachmentId} {
        // Anyone who can read the parent task can read its attachments.
        allow read: if parent.read();
        // Only authenticated users can create attachments (service code will verify task assignment).
        allow create: if request.auth != null;
        // Only the attachment owner or an admin can delete it.
        allow delete: if isAdmin() || resource.data.ownerUid == request.auth.uid;
      }

      match /timeline/{eventId} {
        // Anyone who can read the parent task can read its timeline.
        allow read: if parent.read();
        // Writes are handled by backend services, not directly by clients.
        allow write: if false;
      }
    }
    
    match /issues/{issueId} {
      let issue = resource.data;
      let parentTask = get(/databases/$(database)/documents/tasks/$(issue.taskId)).data;
      
      function isProjectOwner() {
        return request.auth.uid == parentTask.projectOwnerUid;
      }
      function isIssueOwner() {
        return request.auth.uid == issue.ownerUid;
      }
      function isAssignedToIssue() {
        return request.auth.uid in issue.assignedToUids;
      }

      // Read access: Admin, project owner, issue owner, or a user assigned to the issue.
      allow read: if isAdmin() || isProjectOwner() || isIssueOwner() || isAssignedToIssue();

      // Create access: Any user assigned to the parent sub-task, or the issue owner (for edits that create).
      allow create: if request.auth != null && (request.auth.uid in parentTask.assignedToUids || request.auth.uid == parentTask.ownerUid);

      // Update/Delete access: Only the issue owner or an admin.
      allow update, delete: if isAdmin() || isIssueOwner();
    }
    
    match /attendance/{attendanceId} {
       let record = resource.data;
       
       function isRecordOwner() {
         return request.auth.uid == record.userId;
       }
       
       // Admins can read all attendance. Users can read their own.
       allow read: if isAdmin() || isRecordOwner();
       // Only the user themselves can create their own attendance record.
       allow create: if isRecordOwner();
       // No one can update or delete attendance records.
       allow update, delete: if false;
    }
  }
}
