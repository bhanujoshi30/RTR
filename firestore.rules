
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function getUserData(userId) {
      // Use of .data is safe here because the function is only used in contexts
      // where the document read is already allowed by a rule.
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isAdmin() {
      // Check for existence of role field before accessing, prevents errors on new user creation
      return isSignedIn() && 'role' in getUserData(request.auth.uid) && getUserData(request.auth.uid).role == 'admin';
    }

    // Collection: users
    match /users/{userId} {
      // Admins can manage all user documents.
      // Users can read their own document.
      allow read: if isUser(userId) || isAdmin();
      allow write: if isAdmin();
      allow create: if isAdmin(); // Only admins can create user documents via the UI
      allow delete: if isAdmin();
    }

    // Collection: projects
    match /projects/{projectId} {
      function getProjectData() {
        return resource.data;
      }
      
      function isOwner() {
        return isSignedIn() && request.auth.uid == getProjectData().ownerUid;
      }

      function isClient() {
        // Ensure clientUid exists before comparing
        return isSignedIn() && 'clientUid' in getProjectData() && request.auth.uid == getProjectData().clientUid;
      }
      
      function isMember() {
        // Ensure memberUids list exists before checking
        return isSignedIn() && 'memberUids' in getProjectData() && request.auth.uid in getProjectData().memberUids;
      }

      // Read: Admins, owner, client, or a member of the project can read a single project.
      allow get: if isOwner() || isClient() || isMember() || isAdmin();
      
      // List: Admins can list all. Other users can list projects they own, are a client of, or are a member of.
      // This rule structure ensures queries are properly scoped.
      allow list: if isAdmin() || (isSignedIn() && (
        (query.filters.size() > 0 && 'ownerUid' in query.filters[0].field && query.filters[0].value == request.auth.uid) ||
        (query.filters.size() > 0 && 'clientUid' in query.filters[0].field && query.filters[0].value == request.auth.uid) ||
        (query.filters.size() > 0 && 'memberUids' in query.filters[0].field && query.filters[0].value == request.auth.uid)
      ));

      // Create: Any authenticated user can create projects, but the owner must be the creator.
      allow create: if isSignedIn() && request.resource.data.ownerUid == request.auth.uid;
      
      // Update/Delete: Only the project owner or an admin can update/delete.
      allow update, delete: if isOwner() || isAdmin();
    }

    // Collection: tasks
    match /tasks/{taskId} {
      function getTaskCreateData() {
        return request.resource.data;
      }
      
      function getTaskData() {
        return resource.data;
      }

      function getParentProjectData(projectId) {
        return get(/databases/$(database)/documents/projects/$(projectId)).data;
      }

      function isProjectOwnerForTask(taskData) {
        return isSignedIn() && request.auth.uid == getParentProjectData(taskData.projectId).ownerUid;
      }
      
      function isProjectClientForTask(taskData) {
        return isSignedIn() && request.auth.uid == getParentProjectData(taskData.projectId).clientUid;
      }

      function isAssignedToTask(taskData) {
        return isSignedIn() && request.auth.uid in taskData.assignedToUids;
      }

      function isTaskOwner(taskData) {
        return isSignedIn() && request.auth.uid == taskData.ownerUid;
      }
      
      // Read: Admins, project owner, client (for their projects), or assigned user can read a task.
      allow get: if isAdmin() || isProjectOwnerForTask(getTaskData()) || isProjectClientForTask(getTaskData()) || isAssignedToTask(getTaskData()) || isTaskOwner(getTaskData());
      allow list: if isSignedIn(); // Queries from app logic must be specific (e.g., by projectId, assignedToUids)

      // Create: Project owner or admin can create tasks.
      allow create: if isProjectOwnerForTask(getTaskCreateData()) || isAdmin();
      
      // Update: Task owner, assigned user, project owner, or admin can update.
      allow update: if isTaskOwner(getTaskData()) || isAssignedToTask(getTaskData()) || isProjectOwnerForTask(getTaskData()) || isAdmin();
      
      // Delete: Task owner, project owner, or admin can delete.
      allow delete: if isTaskOwner(getTaskData()) || isProjectOwnerForTask(getTaskData()) || isAdmin();

      // Subcollection: attachments
      match /attachments/{attachmentId} {
        allow read: if isAdmin() || isProjectOwnerForTask(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isProjectClientForTask(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isAssignedToTask(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isTaskOwner(get(/databases/$(database)/documents/tasks/$(taskId)).data);
        allow create, delete: if isAssignedToTask(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isTaskOwner(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isAdmin();
      }

      // Subcollection: timeline
      match /timeline/{eventId} {
        allow read: if isAdmin() || isProjectOwnerForTask(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isProjectClientForTask(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isAssignedToTask(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isTaskOwner(get(/databases/$(database)/documents/tasks/$(taskId)).data);
        allow create: if isAssignedToTask(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isTaskOwner(get(/databases/$(database)/documents/tasks/$(taskId)).data) || isAdmin();
        allow delete: if false; // Timeline events are immutable
      }
    }
    
    // Collection: issues
    match /issues/{issueId} {
        function getParentTaskDataForIssue() {
            return get(/databases/$(database)/documents/tasks/$(resource.data.taskId)).data;
        }

        function isParentTaskOwner() {
            return isSignedIn() && request.auth.uid == getParentTaskDataForIssue().ownerUid;
        }

        function isAssignedToParentTask() {
            return isSignedIn() && request.auth.uid in getParentTaskDataForIssue().assignedToUids;
        }
        
        function isAssignedToIssue() {
           return isSignedIn() && request.auth.uid in resource.data.assignedToUids;
        }
        
        function isIssueOwner() {
            return isSignedIn() && request.auth.uid == resource.data.ownerUid;
        }

        allow read: if isAdmin() || isParentTaskOwner() || isAssignedToParentTask();
        allow create: if isAssignedToParentTask() || isParentTaskOwner();
        allow update: if isIssueOwner() || isAssignedToIssue();
        allow delete: if isIssueOwner();
    }
    
    // Collection: attendance
    match /attendance/{attendanceId} {
      allow read: if isAdmin();
      allow create: if isSignedIn();
      allow update, delete: if false; // Attendance records are immutable
    }
  }
}
